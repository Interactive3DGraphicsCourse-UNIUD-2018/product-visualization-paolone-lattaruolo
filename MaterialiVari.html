<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - Materiali Vari</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		color: #222;
		padding: 5px;
		font-family: Monospace;
		font-size: 13px;
		text-align: center;
	}

	a {
		color: #000;
		text-decoration: none;
	}

	a:hover {
		color: #0080ff;
	}
	</style>
</head>
<body>

	<div id="info">
		<a href="https://github.com/robertoranon/int3D" target="_blank">Interactive 3D Graphics 2017 code</a> - normal mapping<br />
	</div>
	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src='lib/dat.gui.min.js'></script>
	<script src='lib/OBJLoader.js'></script>

	<!-- shaders -->

										<!-- shader combinato: lambertian + microfacet; ORO -->
	<script type="text/x-glsl" id="vertex">
	varying vec3 vNormal;
	varying vec3 vPosition;

	void main() {
		vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
		vPosition = vPos.xyz;
		vNormal = normalMatrix * normal;
		gl_Position = projectionMatrix * vPos;
	}
	</script>

	<script type="text/x-glsl" id="fragment">
	varying vec3 vNormal;
	varying vec3 vPosition;
	uniform vec3 pointLightPosition; // in world space
	uniform vec3 pointLightPosition2; // in world space
	uniform vec3 clight;
	uniform vec3 cspec;
	uniform vec3 cdiff;
	uniform float roughness;
	const float PI = 3.14159;

	vec3 FSchlick(float lDoth) {
		return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
	}

	float DGGX(float nDoth, float alpha) {
		float alpha2 = alpha*alpha;
		float d = nDoth*nDoth*(alpha2-1.0)+1.0;
		return (  alpha2 / (PI*d*d));
	}

	float G1(float dotProduct, float k) {
		return (dotProduct / (dotProduct*(1.0-k) + k) );
	}

	float GSmith(float nDotv, float nDotl) {
		float k = roughness*roughness;
		return G1(nDotl,k)*G1(nDotv,k);
	}

	void main() {

		// Luce 1
		vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
		vec3 l = normalize(lPosition.xyz - vPosition.xyz);
		vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
		vec3 v = normalize( -vPosition);
		vec3 h = normalize( v + l);
		// small quantity to prevent divisions by 0
		float nDotl = max(dot( n, l),0.000001);
		float lDoth = max(dot( l , h ),0.000001);
		float nDoth = max(dot( n, h ),0.000001);
		float vDoth = max(dot( v, h ),0.000001);
		float nDotv = max(dot( n, v ),0.000001);
		vec3 fresnel = FSchlick(lDoth);
		vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
		(4.0*nDotl*nDotv);

		// Luce 2
			vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
			vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
			vec3 n2 = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
			vec3 v2 = normalize( -vPosition );
			vec3 h2 = normalize( v + l2 );
			// small quantity to prevent divisions by 0
			float nDotl2 = max(dot( n2, l2),0.000001);
			float lDoth2 = max(dot( l2 , h2 ),0.000001);
			float nDoth2 = max(dot( n2, h2 ),0.000001);
			float vDoth2 = max(dot( v2, h2 ),0.000001);
			float nDotv2 = max(dot( n2, v2 ),0.000001);
			vec3 fresnel2 = FSchlick(lDoth2);
			vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv2,nDotl2)*DGGX(nDoth2,roughness*roughness)/
			(4.0*nDotl2*nDotv2);


		vec3 outRadiance = PI* clight * (nDotl * BRDF + nDotl2 * BRDF2);
		// gamma encode the final value
		gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
	}
	</script>

											<!-- shader combinato: lambertian + microfacet; TEXTURE METALLO GRIGLIA-->

	<script type="text/x-glsl" id="vertexTexture1">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;

	void main() {
		vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
		vPosition = vPos.xyz;
		vNormal = normalMatrix * normal;
		uVv = uv;
		gl_Position = projectionMatrix * vPos;
	}
	</script>

	<script type="text/x-glsl" id="fragmentTexture1">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;
	uniform vec3 pointLightPosition; // in world space
	uniform vec3 pointLightPosition2; // in world space
	uniform vec3 clight;
	uniform sampler2D specularMap2;
	uniform sampler2D diffuseMap2;
	uniform sampler2D roughnessMap2;
	uniform sampler2D normalMap2;
	uniform vec2 normalScale;
	uniform vec2 textureRepeat;
	vec3 cdiff;
	vec3 cspec;
	float roughness;
	const float PI = 3.14159;

	vec3 FSchlick(float lDoth) {
		return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
	}

	float DGGX(float nDoth, float alpha) {
		float alpha2 = alpha*alpha;
		float d = nDoth*nDoth*(alpha2-1.0)+1.0;
		return (  alpha2 / (PI*d*d));
	}

	float G1(float dotProduct, float k) {
		return (dotProduct / (dotProduct*(1.0-k) + k) );
	}

	float GSmith(float nDotv, float nDotl) {
		float k = roughness*roughness;
		return G1(nDotl,k)*G1(nDotv,k);
	}

	#extension GL_OES_standard_derivatives : enable

vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

	vec3 q0 = dFdx( eye_pos.xyz );
	vec3 q1 = dFdy( eye_pos.xyz );
	vec2 st0 = dFdx( uVv.st );
	vec2 st1 = dFdy( uVv.st );

	vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
	vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
	vec3 N =  surf_norm ;

	vec3 mapN = normalize(texture2D( normalMap2, uVv ).xyz * 2.0 - 1.0);
	mapN.xy = normalScale * mapN.xy;
	mat3 tsn = mat3( S, T, N );
	return normalize( tsn * mapN );

}

	void main() {
		vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
		vec3 l = normalize(lPosition.xyz - vPosition.xyz);
		vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		vec3 v = normalize( -vPosition);
		vec3 h = normalize( v + l);
		// small quantity to prevent divisions by 0
		float nDotl = max(dot( n, l ),0.000001);
		float lDoth = max(dot( l, h ),0.000001);
		float nDoth = max(dot( n, h ),0.000001);
		float vDoth = max(dot( v, h ),0.000001);
		float nDotv = max(dot( n, v ),0.000001);

		cdiff = texture2D( diffuseMap2, uVv*textureRepeat ).rgb;
		// texture in sRGB, linearize
		cdiff = pow( cdiff, vec3(2.2));
		cspec = texture2D( specularMap2, uVv*textureRepeat ).rgb;
		// texture in sRGB, linearize
		cspec = pow( cspec, vec3(2.2));
		roughness = texture2D( roughnessMap2, uVv*textureRepeat).r; // no need to linearize roughness map

		vec3 fresnel = FSchlick(lDoth);
		vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
		(4.0*nDotl*nDotv);

		// Luce 2
			vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
			vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
			vec3 n2 = perturbNormal2Arb( vPosition, normalize( vNormal ));
			vec3 v2 = normalize( -vPosition );
			vec3 h2 = normalize( v + l2 );
			// small quantity to prevent divisions by 0
			float nDotl2 = max(dot( n2, l2),0.000001);
			float lDoth2 = max(dot( l2 , h2 ),0.000001);
			float nDoth2 = max(dot( n2, h2 ),0.000001);
			float vDoth2 = max(dot( v2, h2 ),0.000001);
			float nDotv2 = max(dot( n2, v2 ),0.000001);
			vec3 fresnel2 = FSchlick(lDoth2);
			vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv2,nDotl2)*DGGX(nDoth2,roughness*roughness)/
			(4.0*nDotl2*nDotv2);
			vec3 outRadiance = PI* clight * (nDotl * BRDF + nDotl2 * BRDF2);
			// gamma encode the final value
			gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
	}
	</script>

										<!-- shader combinato: lambertian + microfacet; TEXTURE2 LEGNO-->

	<script type="text/x-glsl" id="vertexTexture2">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;

	void main() {
		vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
		vPosition = vPos.xyz;
		vNormal = normalMatrix * normal;
		uVv = uv;
		gl_Position = projectionMatrix * vPos;
	}
	</script>

	<script type="text/x-glsl" id="fragmentTexture2">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;
	uniform vec3 pointLightPosition; // in world space
	uniform vec3 pointLightPosition2; // in world space
	uniform vec3 clight;
	uniform sampler2D specularMap;
	uniform sampler2D diffuseMap;
	uniform sampler2D roughnessMap;
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
	uniform vec2 textureRepeat;
	vec3 cdiff;
	vec3 cspec;
	float roughness;
	const float PI = 3.14159;

	vec3 FSchlick(float lDoth) {
		return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
	}

	float DGGX(float nDoth, float alpha) {
		float alpha2 = alpha*alpha;
		float d = nDoth*nDoth*(alpha2-1.0)+1.0;
		return (  alpha2 / (PI*d*d));
	}

	float G1(float dotProduct, float k) {
		return (dotProduct / (dotProduct*(1.0-k) + k) );
	}

	float GSmith(float nDotv, float nDotl) {
		float k = roughness*roughness;
		return G1(nDotl,k)*G1(nDotv,k);
	}

	#extension GL_OES_standard_derivatives : enable

vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

	vec3 q0 = dFdx( eye_pos.xyz );
	vec3 q1 = dFdy( eye_pos.xyz );
	vec2 st0 = dFdx( uVv.st );
	vec2 st1 = dFdy( uVv.st );

	vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
	vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
	vec3 N =  surf_norm ;

	vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
	mapN.xy = normalScale * mapN.xy;
	mat3 tsn = mat3( S, T, N );
	return normalize( tsn * mapN );

}

	void main() {
		vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
		vec3 l = normalize(lPosition.xyz - vPosition.xyz);
		vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
		vec3 v = normalize( -vPosition);
		vec3 h = normalize( v + l);
		// small quantity to prevent divisions by 0
		float nDotl = max(dot( n, l ),0.000001);
		float lDoth = max(dot( l, h ),0.000001);
		float nDoth = max(dot( n, h ),0.000001);
		float vDoth = max(dot( v, h ),0.000001);
		float nDotv = max(dot( n, v ),0.000001);

		cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
		// texture in sRGB, linearize
		cdiff = pow( cdiff, vec3(2.2));
		cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
		// texture in sRGB, linearize
		cspec = pow( cspec, vec3(2.2));
		roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

		vec3 fresnel = FSchlick(lDoth);
		vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
		(4.0*nDotl*nDotv);

		// Luce 2
			vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
			vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
			vec3 n2 = perturbNormal2Arb( vPosition, normalize( vNormal ));
			vec3 v2 = normalize( -vPosition );
			vec3 h2 = normalize( v + l2 );
			// small quantity to prevent divisions by 0
			float nDotl2 = max(dot( n2, l2),0.000001);
			float lDoth2 = max(dot( l2 , h2 ),0.000001);
			float nDoth2 = max(dot( n2, h2 ),0.000001);
			float vDoth2 = max(dot( v2, h2 ),0.000001);
			float nDotv2 = max(dot( n2, v2 ),0.000001);
			vec3 fresnel2 = FSchlick(lDoth2);
			vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv2,nDotl2)*DGGX(nDoth2,roughness*roughness)/
			(4.0*nDotl2*nDotv2);
			vec3 outRadiance = PI* clight * (nDotl * BRDF + nDotl2 * BRDF2);
			// gamma encode the final value
			gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
	}
	</script>

	<!-- shader combinato: lambertian + microfacet; TEXTURE3 -->

	<script type="text/x-glsl" id="vertexTexture3">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;

	void main() {
	vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
	vPosition = vPos.xyz;
	vNormal = normalMatrix * normal;
	uVv = uv;
	gl_Position = projectionMatrix * vPos;
	}
	</script>

	<script type="text/x-glsl" id="fragmentTexture3">
	varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;
	uniform vec3 pointLightPosition; // in world space
	uniform vec3 pointLightPosition2; // in world space
	uniform vec3 clight;
	uniform sampler2D specularMap3;
	uniform sampler2D diffuseMap3;
	uniform sampler2D roughnessMap3;
	uniform sampler2D normalMap3;
	uniform vec2 normalScale;
	uniform vec2 textureRepeat;
	vec3 cdiff;
	vec3 cspec;
	float roughness;
	const float PI = 3.14159;

	vec3 FSchlick(float lDoth) {
	return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
	}

	float DGGX(float nDoth, float alpha) {
	float alpha2 = alpha*alpha;
	float d = nDoth*nDoth*(alpha2-1.0)+1.0;
	return (  alpha2 / (PI*d*d));
	}

	float G1(float dotProduct, float k) {
	return (dotProduct / (dotProduct*(1.0-k) + k) );
	}

	float GSmith(float nDotv, float nDotl) {
	float k = roughness*roughness;
	return G1(nDotl,k)*G1(nDotv,k);
	}

	#extension GL_OES_standard_derivatives : enable

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

	vec3 q0 = dFdx( eye_pos.xyz );
	vec3 q1 = dFdy( eye_pos.xyz );
	vec2 st0 = dFdx( uVv.st );
	vec2 st1 = dFdy( uVv.st );

	vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
	vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
	vec3 N =  surf_norm ;

	vec3 mapN = normalize(texture2D( normalMap3, uVv ).xyz * 2.0 - 1.0);
	mapN.xy = normalScale * mapN.xy;
	mat3 tsn = mat3( S, T, N );
	return normalize( tsn * mapN );

	}

	void main() {
	vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
	vec3 l = normalize(lPosition.xyz - vPosition.xyz);
	vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
	vec3 v = normalize( -vPosition);
	vec3 h = normalize( v + l);
	// small quantity to prevent divisions by 0
	float nDotl = max(dot( n, l ),0.000001);
	float lDoth = max(dot( l, h ),0.000001);
	float nDoth = max(dot( n, h ),0.000001);
	float vDoth = max(dot( v, h ),0.000001);
	float nDotv = max(dot( n, v ),0.000001);

	cdiff = texture2D( diffuseMap3, uVv*textureRepeat ).rgb;
	// texture in sRGB, linearize
	cdiff = pow( cdiff, vec3(2.2));
	cspec = texture2D( specularMap3, uVv*textureRepeat ).rgb;
	// texture in sRGB, linearize
	cspec = pow( cspec, vec3(2.2));
	roughness = texture2D( roughnessMap3, uVv*textureRepeat).r; // no need to linearize roughness map

	vec3 fresnel = FSchlick(lDoth);
	vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
	(4.0*nDotl*nDotv);

	// Luce 2
	vec4 lPosition2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
	vec3 l2 = normalize(lPosition2.xyz - vPosition.xyz);
	vec3 n2 = perturbNormal2Arb( vPosition, normalize( vNormal ));
	vec3 v2 = normalize( -vPosition );
	vec3 h2 = normalize( v + l2 );
	// small quantity to prevent divisions by 0
	float nDotl2 = max(dot( n2, l2),0.000001);
	float lDoth2 = max(dot( l2 , h2 ),0.000001);
	float nDoth2 = max(dot( n2, h2 ),0.000001);
	float vDoth2 = max(dot( v2, h2 ),0.000001);
	float nDotv2 = max(dot( n2, v2 ),0.000001);
	vec3 fresnel2 = FSchlick(lDoth2);
	vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv2,nDotl2)*DGGX(nDoth2,roughness*roughness)/
	(4.0*nDotl2*nDotv2);
	vec3 outRadiance = PI* clight * (nDotl * BRDF + nDotl2 * BRDF2);
	// gamma encode the final value
	gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
	}
	</script>


	<!-- three.js code -->

	<script>
	var renderer = new THREE.WebGLRenderer( { antialias: true } );
	var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
	var controls = new THREE.OrbitControls( camera, renderer.domElement );
	var scene = new THREE.Scene();

	// default: white, 1.0 intensity
	var lightParameters = {
		red: 1.0,
		green: 1.0,
		blue: 1.0,
		intensity: 1.0,
	}

	// default: red plastic
	var materialParameters = {
		cdiff_red: 0.0,
		cdiff_green: 0.0,
		cdiff_blue: 0.0,
		cspec_red: 1.022,
		cspec_green: 0.782,
		cspec_blue: 0.344,
		roughness: 0.1
	}

	var textureParameters = {
		material: "Metallo1",
		repeatS: 1.0,
		repeatT: 1.0,
		material2:"Metallo2",
		repeatS: 1.0,
		repeatT: 1.0,
		material3:"Wood1",
		repeatS: 1.0,
		repeatT: 1.0,
		normalScale: 0.0,
	}

	// Texture per sfera con lastra di ferro
	var diffuseMap = loadTexture( "texture/Metallo1/" + textureParameters.material + "_Diffuse.png" );
	var specularMap = loadTexture( "texture/Metallo1/" + textureParameters.material + "_Specular.png" );
	var roughnessMap = loadTexture( "texture/Metallo1/" + textureParameters.material + "_Roughness.png" );
	var normalMap = loadTexture( "texture/Metallo1/" + textureParameters.material + "_Normal.png" );

	// Texture per sfera con mattoncini
	var diffuseMap2 = loadTexture( "texture/Metallo2/" + textureParameters.material2 + "_Diffuse.png" );
	var specularMap2 = loadTexture( "texture/Metallo2/" + textureParameters.material2 + "_Specular.png" );
	var roughnessMap2 = loadTexture( "texture/Metallo2/" + textureParameters.material2 + "_Roughness.png" );
	var normalMap2 = loadTexture( "texture/Metallo2/" + textureParameters.material2 + "_Normal.png" );

	// Texture per sfera con
	var diffuseMap3 = loadTexture( "texture/Wood1/" + textureParameters.material3 + "_Diffuse.jpg" );
	var specularMap3 = loadTexture( "texture/Wood1/" + textureParameters.material3 + "_Specular.jpg" );
	var roughnessMap3 = loadTexture( "texture/Wood1/" + textureParameters.material3 + "_Roughness.jpg" );
	var normalMap3 = loadTexture( "texture/Wood1/" + textureParameters.material3 + "_Normal.jpg" );

	var uniforms = {
		// Mappe texture sfera mettallica
		specularMap: { type: "t", value: specularMap},
		diffuseMap:	{ type: "t", value: diffuseMap},
		roughnessMap:	{ type: "t", value: roughnessMap},
		normalMap:	{ type: "t", value: normalMap},

		// Mappe texture sfera legno
		specularMap2: { type: "t", value: specularMap2},
		diffuseMap2:	{ type: "t", value: diffuseMap2},
		roughnessMap2:	{ type: "t", value: roughnessMap2},
		normalMap2:	{ type: "t", value: normalMap2},

		// Mappe texture sfera legno
		specularMap3: { type: "t", value: specularMap3},
		diffuseMap3:	{ type: "t", value: diffuseMap3},
		roughnessMap3:	{ type: "t", value: roughnessMap3},
		normalMap3:	{ type: "t", value: normalMap3},

		normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
		textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) },

		cspec:	{ type: "v3", value: new THREE.Vector3() },
		cdiff:	{ type: "v3", value: new THREE.Vector3() },
		roughness: {type: "f", value: 0.5},

		pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
		pointLightPosition2:	{ type: "v3", value: new THREE.Vector3() },

		clight:	{ type: "v3", value: new THREE.Vector3() },
	};

	vs = document.getElementById("vertex").textContent;
	fs = document.getElementById("fragment").textContent;

	vs2 = document.getElementById("vertexTexture1").textContent;
	fs2 = document.getElementById("fragmentTexture1").textContent;

	vs3 = document.getElementById("vertexTexture2").textContent;
	fs3 = document.getElementById("fragmentTexture2").textContent;

	vs4 = document.getElementById("vertexTexture3").textContent;
	fs4 = document.getElementById("fragmentTexture3").textContent;


	var ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
	var ourMaterial2 = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs2, fragmentShader: fs2 });
	var ourMaterial3 = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs3, fragmentShader: fs3 });
	var ourMaterial4 = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs4, fragmentShader: fs4 });
	var geometrySfera1 = new THREE.SphereGeometry(4, 32, 32);
	var cube = new THREE.BoxGeometry(5,5,5);

	var sfera1 = new THREE.Mesh(geometrySfera1, ourMaterial);
	var sfera2 = new THREE.Mesh(geometrySfera1, ourMaterial2);
	var sfera3 = new THREE.Mesh(geometrySfera1, ourMaterial3);
	var sfera4 = new THREE.Mesh(geometrySfera1, ourMaterial4);


	sfera1.position.set(0,10,0);
	sfera2.position.set(10,10,0);
	sfera3.position.set(-20,10,0);
	sfera4.position.set(-10,10,0);

	var lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16), new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
	lightMesh.position.set( -10, 25.0, 0 );
	uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,
		lightMesh.position.y,
		lightMesh.position.z);

		var lightMesh2 = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16), new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
		lightMesh2.position.set( 0, 0, 0 );
		lightMesh2.rotation.set( 90*Math.PI/180, 0, 0 );
		uniforms.pointLightPosition2.value = new THREE.Vector3(lightMesh2.position.x,
			lightMesh2.position.y,
			lightMesh2.position.z);

		var stats = new Stats();

		function loadTexture(file) {
			var texture = new THREE.TextureLoader().load( file , function ( texture ) {

				texture.minFilter = THREE.LinearMipMapLinearFilter;
				texture.anisotropy = renderer.getMaxAnisotropy();
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.offset.set( 0, 0 );
				texture.needsUpdate = true;
				render();
			} )
			return texture;
		}

		function init() {

			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.setClearColor( 0xf0f0f0 );

			camera.position.set( 0, 0, -50 );
			scene.add(sfera1, sfera2, sfera3, sfera4, lightMesh, lightMesh2, camera);

			document.body.appendChild( renderer.domElement );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			controls.addEventListener( 'change', render );
			controls.minDistance = 1;
			controls.maxDistance = 100;
			//controls.maxPolarAngle = Math.PI / 2;
			controls.enablePan = false;
			controls.target.copy( sfera1.position );
			controls.target.copy( sfera2.position );
			controls.target.copy( sfera3.position );
			controls.update();

			window.addEventListener( 'resize', onResize, false );


			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

		}

		function onResize() {

			renderer.setSize( window.innerWidth, window.innerHeight );
			camera.aspect = ( window.innerWidth / window.innerHeight );
			camera.updateProjectionMatrix();

		}

		function update() {
			requestAnimationFrame( update );
			stats.update();
			render();
		}

		function render() {
			updateUniforms();
			renderer.render( scene, camera );
		}

		function updateUniforms() {

			uniforms.cspec.value = new THREE.Vector3(materialParameters.cspec_red,
				materialParameters.cspec_green,materialParameters.cspec_blue);
				uniforms.cdiff.value = new THREE.Vector3(materialParameters.cdiff_red,
					materialParameters.cdiff_green,materialParameters.cdiff_blue);
					uniforms.roughness.value = materialParameters.roughness>0.0?materialParameters.roughness:0.01;
					uniforms.clight.value = new THREE.Vector3(
						lightParameters.red * lightParameters.intensity,
						lightParameters.green * lightParameters.intensity,
						lightParameters.blue * lightParameters.intensity);
					}


					init();
					update();
					render();

					</script>
				</body>
				</html>
