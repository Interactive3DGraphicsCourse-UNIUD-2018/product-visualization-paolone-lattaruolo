<!DOCTYPE html>
<html lang="en">
<head>
	<title>Project</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden;
	}

	#info {
		position: absolute;
		top: 0px; width: 100%;
		color: #222;
		padding: 5px;
		font-family: Monospace;
		font-size: 13px;
		text-align: center;
	}

	a {
		color: #000;
		text-decoration: none;
	}

	a:hover {
		color: #0080ff;
	}
	</style>
</head>
<body>

	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/OrbitControls.js"></script>
	<script src="lib/dat.gui.min.js"></script>
	<script src="lib/GLTFLoader.js"></script>

	<!-- shader combinato: lambertian + microfacet; ORO -->
	<script type="text/x-glsl" id="vertex">
	varying vec3 vNormal;
	varying vec3 vPosition;

	void main() {
		vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
		vPosition = vPos.xyz;
		vNormal = normalMatrix * normal;
		gl_Position = projectionMatrix * vPos;
	}
</script>

<script type="text/x-glsl" id="fragment">
varying vec3 vNormal;
varying vec3 vPosition;
uniform vec3 pointLightPosition; // in world space
uniform vec3 ambientLight;
uniform vec3 clight;
uniform vec3 cspec;
uniform vec3 cdiff;
uniform float roughness;
const float PI = 3.14159;

vec3 FSchlick(float lDoth) {
	return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
}

float DGGX(float nDoth, float alpha) {
	float alpha2 = alpha*alpha;
	float d = nDoth*nDoth*(alpha2-1.0)+1.0;
	return (  alpha2 / (PI*d*d));
}

float G1(float dotProduct, float k) {
	return (dotProduct / (dotProduct*(1.0-k) + k) );
}

float GSmith(float nDotv, float nDotl) {
	float k = roughness*roughness;
	return G1(nDotl,k)*G1(nDotv,k);
}

void main() {

	// Luce 1
	vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
	vec3 l = normalize(lPosition.xyz - vPosition.xyz);
	vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
	vec3 v = normalize( -vPosition);
	vec3 h = normalize( v + l);
	// small quantity to prevent divisions by 0
	float nDotl = max(dot( n, l),0.000001);
	float lDoth = max(dot( l , h ),0.000001);
	float nDoth = max(dot( n, h ),0.000001);
	float vDoth = max(dot( v, h ),0.000001);
	float nDotv = max(dot( n, v ),0.000001);
	vec3 fresnel = FSchlick(lDoth);
	vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
	(4.0*nDotl*nDotv);
	vec3 outRadiance = PI* clight * nDotl * BRDF + (ambientLight*0.15);
	// gamma encode the final value
	gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
}
</script>

<script type="text/x-glsl" id="vertexTexture1">
varying vec3 vNormal;
varying vec3 vPosition;
varying vec2 uVv;

void main() {
	vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
	vPosition = vPos.xyz;
	vNormal = normalMatrix * normal;
	uVv = uv;
	gl_Position = projectionMatrix * vPos;
}
</script>

<script type="text/x-glsl" id="fragmentTexture1">
varying vec3 vNormal;
varying vec3 vPosition;
varying vec2 uVv;
uniform vec3 pointLightPosition; // in world space
uniform vec3 ambientLight;
uniform vec3 clight;
uniform sampler2D specularMap;
uniform sampler2D diffuseMap;
uniform sampler2D roughnessMap;
uniform sampler2D normalMap;
uniform sampler2D aoMap;
uniform vec2 normalScale;
uniform vec2 textureRepeat;
vec3 cdiff;
vec3 cspec;
float roughness;
const float PI = 3.14159;

vec3 FSchlick(float lDoth) {
	return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
}

float DGGX(float nDoth, float alpha) {
	float alpha2 = alpha*alpha;
	float d = nDoth*nDoth*(alpha2-1.0)+1.0;
	return (  alpha2 / (PI*d*d));
}

float G1(float dotProduct, float k) {
	return (dotProduct / (dotProduct*(1.0-k) + k) );
}

float GSmith(float nDotv, float nDotl) {
	float k = roughness*roughness;
	return G1(nDotl,k)*G1(nDotv,k);
}

#extension GL_OES_standard_derivatives : enable

vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {

vec3 q0 = dFdx( eye_pos.xyz );
vec3 q1 = dFdy( eye_pos.xyz );
vec2 st0 = dFdx( uVv.st );
vec2 st1 = dFdy( uVv.st );

vec3 S = normalize(  q0 * st1.t - q1 * st0.t );
vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
vec3 N =  surf_norm ;

vec3 mapN = normalize(texture2D( normalMap, uVv ).xyz * 2.0 - 1.0);
mapN.xy = normalScale * mapN.xy;
mat3 tsn = mat3( S, T, N );
return normalize( tsn * mapN );

}

void main() {
	vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
	vec3 l = normalize(lPosition.xyz - vPosition.xyz);
	vec3 n = perturbNormal2Arb( vPosition, normalize( vNormal ));
	vec3 v = normalize( -vPosition);
	vec3 h = normalize( v + l);
	// small quantity to prevent divisions by 0
	float nDotl = max(dot( n, l ),0.000001);
	float lDoth = max(dot( l, h ),0.000001);
	float nDoth = max(dot( n, h ),0.000001);
	float vDoth = max(dot( v, h ),0.000001);
	float nDotv = max(dot( n, v ),0.000001);

	cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
	// texture in sRGB, linearize
	cdiff = pow( cdiff, vec3(2.2));
	cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
	// texture in sRGB, linearize
	cspec = pow( cspec, vec3(2.2));
	roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map

	vec3 fresnel = FSchlick(lDoth);
	vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
	(4.0*nDotl*nDotv);
	vec3 outRadiance = PI* clight * nDotl * BRDF + ambientLight*texture2D( aoMap, uVv*textureRepeat).xyz*cdiff;
	// gamma encode the final value
	gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
}
</script>

<!-- shader combinato: lambertian + microfacet; ORO -->
<script type="text/x-glsl" id="vertex2">
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
	vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
	vPosition = vPos.xyz;
	vNormal = normalMatrix * normal;
	gl_Position = projectionMatrix * vPos;
}
</script>

<script type="text/x-glsl" id="fragment2">
varying vec3 vNormal;
varying vec3 vPosition;
uniform vec3 pointLightPosition; // in world space
uniform vec3 ambientLight;
uniform vec3 clight;
uniform vec3 cspec;
uniform vec3 cdiff;
uniform float roughness;
const float PI = 3.14159;

vec3 FSchlick(float lDoth) {
return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
}

float DGGX(float nDoth, float alpha) {
float alpha2 = alpha*alpha;
float d = nDoth*nDoth*(alpha2-1.0)+1.0;
return (  alpha2 / (PI*d*d));
}

float G1(float dotProduct, float k) {
return (dotProduct / (dotProduct*(1.0-k) + k) );
}

float GSmith(float nDotv, float nDotl) {
float k = roughness*roughness;
return G1(nDotl,k)*G1(nDotv,k);
}

void main() {

// Luce 1
vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
vec3 l = normalize(lPosition.xyz - vPosition.xyz);
vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
vec3 v = normalize( -vPosition);
vec3 h = normalize( v + l);
// small quantity to prevent divisions by 0
float nDotl = max(dot( n, l),0.000001);
float lDoth = max(dot( l , h ),0.000001);
float nDoth = max(dot( n, h ),0.000001);
float vDoth = max(dot( v, h ),0.000001);
float nDotv = max(dot( n, v ),0.000001);
vec3 fresnel = FSchlick(lDoth);
vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
(4.0*nDotl*nDotv);
vec3 outRadiance = PI* clight * nDotl * BRDF + (ambientLight*0.15);
// gamma encode the final value
gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
}
</script>

<script>
var stats, controls;
var camera, scene, renderer, light;
var textureParameters,materialParameters;
var diffuseMap,specularMap, roughnessMap, normalMap,aoMap;
var textureParametersCassetti,materialParametersCassetti;
var diffuseMapCassetti,specularMapCassetti, roughnessMapCassetti, normalMapCassetti,aoMapCassetti;
var materialeCorpo = "Oro", materialeCassetti = "Plastica";
var shaderCorpo, shaderCassetti;
// default: white, 1.0 intensity
var lightParameters = {
	red: 1.0,
	green: 1.0,
	blue: 1.0,
	intensity: 1.0,
}

var ambientLightParameters = {
	red: 0.2,
	green: 0.2,
	blue: 0.2,
	intensity: 1.0,
}

var materialParametersPlastic = {
	//plastic material for the color just modify red,green blue cdiff parameters
	cdiff_red: 0.2,
	cdiff_green: 0.3,
	cdiff_blue: 0.9,
	cspec_red: 0.04,
	cspec_green: 0.04,
	cspec_blue: 0.04,
	roughness: 0.83
}

var materialParametersTitanio = {
	//titan metal cspec parameters
	cdiff_red: 0.0,
	cdiff_green: 0.0,
	cdiff_blue: 0.0,
	cspec_red: 0.542,
	cspec_green: 0.497,
	cspec_blue: 0.449,
	roughness: 0.83
}

var materialParametersOro = {
	//gold metal cspec parameters
	cdiff_red: 0.0,
	cdiff_green: 0.0,
	cdiff_blue: 0.0,
	cspec_red: 1.022,
	cspec_green: 0.782,
	cspec_blue: 0.344,
	roughness: 0.5
}

// Texture metallo
// var diffuseMap = loadTexture( "texture/Metallo2/" + textureParameters.material1 + "Base_Color.png" );
// var specularMap = loadTexture( "texture/Metallo2/" + textureParameters.material1 + "_Specular.png" );
// var roughnessMap = loadTexture( "texture/Metallo2/" + textureParameters.material1 + "_Roughness.png" );
// var normalMap = loadTexture( "texture/Metallo2/" + textureParameters.material1 + "_Normal.png" );

var diffuseMapLegnoPino = loadTexture( "texture/LegnoPino/LegnoPino_Base_Color.png" );
var specularMapLegnoPino = loadTexture( "texture/LegnoPino/LegnoPino_Specular.png" );
var roughnessMapLegnoPino = loadTexture( "texture/LegnoPino/LegnoPino_Roughness.png" );
var normalMapLegnoPino = loadTexture( "texture/LegnoPino/LegnoPino_Normal.png" );
var aoMapLegnoPino = loadTexture( "texture/LegnoPino/LegnoPino_Ambient_Occlusion.png" );

var diffuseMapLegnoEbano = loadTexture( "texture/LegnoEbano/LegnoEbano_Base_Color.jpg" );
var specularMapLegnoEbano = loadTexture( "texture/LegnoEbano/LegnoEbano_Specular.jpg" );
var roughnessMapLegnoEbano = loadTexture( "texture/LegnoEbano/LegnoEbano_Roughness.jpg" );
var normalMapLegnoEbano = loadTexture( "texture/LegnoEbano/LegnoEbano_Normal.jpg" );
var aoMapLegnoEbano = loadTexture( "texture/LegnoEbano/LegnoEbano_Ambient_Occlusion.jpg" );

var uniforms = {
	cspec:	{ type: "v3", value: new THREE.Vector3() },
	cdiff:	{ type: "v3", value: new THREE.Vector3() },
	roughness: {type: "f", value: 0.5},

	pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
	ambientLight:	{ type: "v3", value: new THREE.Vector3() },
	clight:	{ type: "v3", value: new THREE.Vector3() },
}

var uniformsCassetti = {
	cspec:	{ type: "v3", value: new THREE.Vector3() },
	cdiff:	{ type: "v3", value: new THREE.Vector3() },
	roughness: {type: "f", value: 0.5},

	pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
	ambientLight:	{ type: "v3", value: new THREE.Vector3() },
	clight:	{ type: "v3", value: new THREE.Vector3() },
}

var uniformLegnoPino = {
	specularMap: { type: "t", value: specularMap},
	diffuseMap:	{ type: "t", value: diffuseMap},
	roughnessMap:	{ type: "t", value: roughnessMap},
	normalMap:	{ type: "t", value: normalMap},
	aoMap:	{ type: "t", value: aoMap},
	normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
	textureRepeat: { type: "v2", value: new THREE.Vector2(2,2) },

	cspec:	{ type: "v3", value: new THREE.Vector3() },
	cdiff:	{ type: "v3", value: new THREE.Vector3() },
	roughness: {type: "f", value: 0.5},

	pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
	ambientLight:	{ type: "v3", value: new THREE.Vector3() },
	clight:	{ type: "v3", value: new THREE.Vector3() },
};

var uniformsLengoEbano = {
	specularMap: { type: "t", value: specularMapLegnoEbano},
	diffuseMap:	{ type: "t", value: diffuseMapLegnoEbano},
	roughnessMap:	{ type: "t", value: roughnessMapLegnoEbano},
	normalMap:	{ type: "t", value: normalMapLegnoEbano},
	aoMap:	{ type: "t", value: aoMapLegnoEbano},
	normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
	textureRepeat: { type: "v2", value: new THREE.Vector2(2,2) },

	cspec:	{ type: "v3", value: new THREE.Vector3() },
	cdiff:	{ type: "v3", value: new THREE.Vector3() },
	roughness: {type: "f", value: 0.5},

	pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
	ambientLight:	{ type: "v3", value: new THREE.Vector3() },
	clight:	{ type: "v3", value: new THREE.Vector3() },
};

function loadTexture(file) {
	var texture = new THREE.TextureLoader().load( file , function ( texture ) {

		texture.minFilter = THREE.LinearMipMapLinearFilter;
		texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
		texture.wrapS = texture.wrapT = THREE.MirroredRepeatWrapping;
		texture.offset.set( 0, 0 );
		texture.needsUpdate = true;
		render();
	} )
	return texture;
}

vs = document.getElementById("vertex").textContent;
fs = document.getElementById("fragment").textContent;

vs2 = document.getElementById("vertexTexture1").textContent;
fs2 = document.getElementById("fragmentTexture1").textContent;

function init() {

	camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( 0, 0, -25 );
	controls = new THREE.OrbitControls( camera );
	controls.target.set( 0, -0.2, -0.2 );
	controls.update();
	scene = new THREE.Scene();
	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.gammaInput = true;
	renderer.gammaOutput = true;
	renderer.setClearColor( 0xf0f0f0 );
	renderer.gammaOutput = true;
	window.addEventListener( 'resize', onWindowResize, false );
	// stats
	stats = new Stats();
	document.body.appendChild( renderer.domElement );
	document.body.appendChild( stats.domElement );
	// model
	scegliMateriali(materialeCorpo,materialeCassetti);//setta i parametri per gli shader

	var loader = new THREE.GLTFLoader();
	loader.load( 'object/comodino/model.glb', function ( gltf ) {

		//--------------------------    GESTIONE MATERIALI COMODINI ------------------------------------------------ //
		if(shaderCorpo=="Texture"){
			gltf.scene.children[0].children[0].traverse( function ( child ) {

				if(child.isMesh){
					//lati uguali dx - sx e gambe davanti
					child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs2, fragmentShader: fs2 });
				}
			});

			gltf.scene.children[0].children[1].traverse( function ( child ) {

				if(child.isMesh){
					//lato sotto
					child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs2, fragmentShader: fs2 });
				}
			});

			gltf.scene.children[0].children[2].traverse( function ( child ) {

				if(child.isMesh){
					//lato cassetti (superficie no casseti)
					child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs2, fragmentShader: fs2 });
				}
			});

			gltf.scene.children[0].children[4].traverse( function ( child ) {

				if(child.isMesh){
					//lato dietro(opposto ai cassetti) e sopra (piano di appoggio)
					child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs2, fragmentShader: fs2 });
				}
			});
	}else{
		gltf.scene.children[0].children[0].traverse( function ( child ) {

			if(child.isMesh){
				//lati uguali dx - sx e gambe davanti
				child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
			}
		});

		gltf.scene.children[0].children[1].traverse( function ( child ) {

			if(child.isMesh){
				//lato sotto
				child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
			}
		});

		gltf.scene.children[0].children[2].traverse( function ( child ) {

			if(child.isMesh){
				//lato cassetti (superficie no casseti)
				child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
			}
		});

		gltf.scene.children[0].children[4].traverse( function ( child ) {

			if(child.isMesh){
				//lato dietro(opposto ai cassetti) e sopra (piano di appoggio)
				child.material =  new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
			}
		});
	}

	if(shaderCassetti=="Texture"){
		gltf.scene.children[0].children[3].traverse( function ( child ) {
			if(child.isMesh){
				//piedi e cassetti
				child.material =  new THREE.ShaderMaterial({ uniforms: uniformsCassetti, vertexShader: vs2, fragmentShader: fs2 });
			}
		});
	}else{
		gltf.scene.children[0].children[3].traverse( function ( child ) {
			if(child.isMesh){
				//piedi e cassetti
				child.material =  new THREE.ShaderMaterial({ uniforms: uniformsCassetti, vertexShader: vs, fragmentShader: fs });
			}
		});
	}

		gltf.scene.scale.multiplyScalar( 0.01 );
		gltf.scene.position.set(0,0,0);
		scene.add( gltf.scene );
	} );

	var lightMesh = new THREE.Mesh( new THREE.SphereGeometry( 1, 16, 16), new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
	lightMesh.position.set( -10, 10.0, 10.0 );
	uniforms.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,
		lightMesh.position.y,
		lightMesh.position.z);
	uniformsCassetti.pointLightPosition.value = new THREE.Vector3(lightMesh.position.x,
		lightMesh.position.y,
		lightMesh.position.z);
		scene.add( lightMesh );
}

function scegliMateriali(corpo, cassetti)
{
	//cassetti comprende anche i piedini
	switch(corpo){
		case "LegnoPino":

			diffuseMap = diffuseMapLegnoPino;
			specularMap = specularMapLegnoPino;
			roughnessMap = roughnessMapLegnoPino;
			normalMap = normalMapLegnoPino;
			aoMap = aoMapLegnoPino;

			uniforms = uniformLegnoPino;
			shaderCorpo ="Texture";
			textureParameters = {
				material:"LegnoPino",
				repeatS: 8.0,
				repeatT: 8.0,
				normalScale: 0.2,
			};
			break;
		case "LegnoEbano":

			diffuseMap = diffuseMapLegnoEbano;
			specularMap = specularMapLegnoEbano;
			roughnessMap = roughnessMapLegnoEbano;
			normalMap = normalMapLegnoEbano;
			aoMap = aoMapLegnoEbano;

			uniforms = uniformsLengoEbano;
			shaderCorpo ="Texture";
			textureParameters = {
				material:"LegnoEbano",
				repeatS: 3.0,
				repeatT: 3.0,
				normalScale: 0.2,
			};
			break;
		case "Titanio":
			shaderCorpo ="Materiale";
			materialParameters = materialParametersTitanio;
			break;
		case "Oro":
			shaderCorpo ="Materiale";
			materialParameters = materialParametersOro;
			break;
		case "Plastica":
			shaderCorpo ="Materiale";
			materialParameters = materialParametersPlastic;
			break;
		default:
		//legno pino

			diffuseMap = diffuseMapLegnoPino;
			specularMap = specularMapLegnoPino;
			roughnessMap = roughnessMapLegnoPino;
			normalMap = normalMapLegnoPino;
			aoMap = aoMapLegnoPino;

			uniforms = uniformLegnoPino;
			shaderCorpo ="Texture";
			textureParameters = {
				material:"LegnoPino",
				repeatS: 8.0,
				repeatT: 8.0,
				normalScale: 0.2,
			};
	}
	switch (cassetti){
		case "LegnoPino":

			diffuseMapCassetti = diffuseMapLegnoPino;
			specularMapCassetti = specularMapLegnoPino;
			roughnessMapCassetti = roughnessMapLegnoPino;
			normalMapCassetti = normalMapLegnoPino;
			aoMapCassetti = aoMapLegnoPino;

			uniformsCassetti = uniformLegnoPino;
			shaderCassetti ="Texture";
			textureParametersCassetti = {
				material:"LegnoPino",
				repeatS: 8.0,
				repeatT: 8.0,
				normalScale: 0.2,
			};
			break;
		case "LegnoEbano":

			diffuseMapCassetti = diffuseMapLegnoEbano;
			specularMapCassetti = specularMapLegnoEbano;
			roughnessMapCassetti = roughnessMapLegnoEbano;
			normalMapCassetti = normalMapLegnoEbano;
			aoMapCassetti = aoMapLegnoEbano;

			uniformsCassetti = uniformsLengoEbano;
			shaderCassetti ="Texture";
			textureParametersCassetti = {
				material:"LegnoEbano",
				repeatS: 3.0,
				repeatT: 3.0,
				normalScale: 0.2,
			};
			break;
		case "Titanio":
			shaderCassetti ="Materiale";
			materialParametersCassetti = materialParametersTitanio;
			break;
		case "Oro":
			shaderCassetti ="Materiale";
			materialParametersCassetti = materialParametersOro;
			break;
		case "Plastica":
			shaderCassetti ="Materiale";
			materialParametersCassetti = materialParametersPlastic;
			break;
		default:
		//legno pino

			diffuseMapCassetti = diffuseMapLegnoPino;
			specularMapCassetti = specularMapLegnoPino;
			roughnessMapCassetti = roughnessMapLegnoPino;
			normalMapCassetti = normalMapLegnoPino;
			aoMapCassetti = aoMapLegnoPino;
			materialParametersCassetti = materialParametersPlastic;
			uniformsCassetti = uniformLegnoPino;
			shaderCassetti ="Texture";
			textureParametersCassetti = {
				material:"LegnoPino",
				repeatS: 8.0,
				repeatT: 8.0,
				normalScale: 0.2,
			};
	}
}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function update() {
			requestAnimationFrame( update );
			stats.update();
			render();
		}

		function render() {
			updateUniforms();
			renderer.render( scene, camera );
		}

		function updateUniforms() {
			if(shaderCorpo=="Materiale"){
				uniforms.cspec.value = new THREE.Vector3(materialParameters.cspec_red,materialParameters.cspec_green,materialParameters.cspec_blue);

				uniforms.cdiff.value = new THREE.Vector3(materialParameters.cdiff_red,materialParameters.cdiff_green,materialParameters.cdiff_blue);

				uniforms.roughness.value = materialParameters.roughness>0.0?materialParameters.roughness:0.01;
		}
		if(shaderCassetti=="Materiale"){
				uniformsCassetti.cspec.value = new THREE.Vector3(materialParametersCassetti.cspec_red,materialParametersCassetti.cspec_green,materialParametersCassetti.cspec_blue);

				uniformsCassetti.cdiff.value = new THREE.Vector3(materialParametersCassetti.cdiff_red,materialParametersCassetti.cdiff_green,materialParametersCassetti.cdiff_blue);

				uniformsCassetti.roughness.value = materialParametersCassetti.roughness>0.0?materialParametersCassetti.roughness:0.01;
			}
			uniforms.clight.value = new THREE.Vector3(	lightParameters.red * lightParameters.intensity,
																									lightParameters.green * lightParameters.intensity,
																									lightParameters.blue * lightParameters.intensity);

			uniforms.ambientLight.value = new THREE.Vector3(
							 ambientLightParameters.red * ambientLightParameters.intensity,
							 ambientLightParameters.green * ambientLightParameters.intensity,
							 ambientLightParameters.blue * ambientLightParameters.intensity);

		 uniformsCassetti.clight.value = new THREE.Vector3(	lightParameters.red * lightParameters.intensity,
																									lightParameters.green * lightParameters.intensity,
																									lightParameters.blue * lightParameters.intensity);

			uniformsCassetti.ambientLight.value = new THREE.Vector3(
							 ambientLightParameters.red * ambientLightParameters.intensity,
							 ambientLightParameters.green * ambientLightParameters.intensity,
							 ambientLightParameters.blue * ambientLightParameters.intensity);

			if(shaderCorpo=="Texture"){
				uniforms.textureRepeat.value = new THREE.Vector2( textureParameters.repeatS, textureParameters.repeatT);
				uniforms.diffuseMap.value = diffuseMap;
				uniforms.specularMap.value = specularMap;
				uniforms.roughnessMap.value = roughnessMap;
				uniforms.normalMap.value = normalMap;
				uniforms.normalScale.value = new THREE.Vector2( textureParameters.normalScale, textureParameters.normalScale );
				uniforms.aoMap.value = aoMap;
			}
			if(shaderCassetti=="Texture"){
				uniformsCassetti.textureRepeat.value = new THREE.Vector2( textureParametersCassetti.repeatS, textureParametersCassetti.repeatT);
				uniformsCassetti.diffuseMap.value = diffuseMapCassetti;
				uniformsCassetti.specularMap.value = specularMapCassetti;
				uniformsCassetti.roughnessMap.value = roughnessMapCassetti;
				uniformsCassetti.normalMap.value = normalMapCassetti;
				uniformsCassetti.normalScale.value = new THREE.Vector2( textureParametersCassetti.normalScale, textureParametersCassetti.normalScale );
				uniformsCassetti.aoMap.value = aoMapCassetti;
			}
		}

					init();
					update();
					render();
					</script>
				</body>
				</html>
